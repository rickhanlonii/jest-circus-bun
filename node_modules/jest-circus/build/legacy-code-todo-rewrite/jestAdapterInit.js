'use strict';

console.log('## Hittt 1');
Object.defineProperty(exports, '__esModule', {
  value: true
});
console.log('## Hittt 2');
exports.runAndTransformResultsToJestFormat = exports.initialize = void 0;
console.log('## Hittt 2.1');
try {
  var _expect = require('@jest/expect');
} catch (e) {
  console.log(e);
}
console.log('## Hittt 2.2');
var _testResult = require('@jest/test-result');
console.log('## Hittt 2.3');
var _jestMessageUtil = require('jest-message-util');
console.log('## Hittt 2.4');
// var _jestSnapshot = require('jest-snapshot');
console.log('## Hittt 2.4');
var _ = _interopRequireDefault(require('..'));
console.log('## Hittt 2.5');
var _run = _interopRequireDefault(require('../run'));
console.log('## Hittt 2.6');
var _state = require('../state');
console.log('## Hittt 2.7');
var _testCaseReportHandler = _interopRequireDefault(
  require('../testCaseReportHandler')
);
console.log('## Hittt 2.8');
var _utils = require('../utils');
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
console.log('## Hittt 3');
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



class SnapshotState {
  constructor(snapshotPath, options) {
    this._snapshotPath = snapshotPath;
    const {data, dirty} = {
      data: {},
dirty: false,
  };
    this._initialData = data;
    this._snapshotData = data;
    this._dirty = dirty;
    this._prettierPath = options.prettierPath ?? null;
    this._inlineSnapshots = [];
    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));
    this._counters = new Map();
    this._index = 0;
    this.expand = options.expand || false;
    this.added = 0;
    this.matched = 0;
    this.unmatched = 0;
    this._updateSnapshot = options.updateSnapshot;
    this.updated = 0;
    this.snapshotFormat = options.snapshotFormat;
    this._rootDir = options.rootDir;
  }

  markSnapshotsAsCheckedForTest(testName) {
    this._uncheckedKeys.forEach(uncheckedKey => {
      if (keyToTestName(uncheckedKey) === testName) {
        this._uncheckedKeys.delete(uncheckedKey);
      }
    });
  }

  _addSnapshot(
    key,
    receivedSerialized,
    options
  ) {
  }

  clear() {
    this._snapshotData = this._initialData;
    this._inlineSnapshots = [];
    this._counters = new Map();
    this._index = 0;
    this.added = 0;
    this.matched = 0;
    this.unmatched = 0;
    this.updated = 0;
  }

  save() {
    return {}
  }

  getUncheckedCount() {
    return this._uncheckedKeys.size || 0;
  }

  getUncheckedKeys() {
    return Array.from(this._uncheckedKeys);
  }

  removeUncheckedKeys() {

  }

  match({
          testName,
          received,
          key,
          inlineSnapshot,
          isInline,
          error,
        }) {

  }

  fail(testName, _received, key) {
    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);
    const count = Number(this._counters.get(testName));

    if (!key) {
      key = testNameToKey(testName, count);
    }

    this._uncheckedKeys.delete(key);
    this.unmatched++;
    return key;
  }
}


const initialize = async ({
  config,
  environment,
  globalConfig,
  localRequire,
  parentProcess,
  sendMessageToJest,
  setGlobalsForRuntime,
  testPath
}) => {
  console.log('### 1');
  if (globalConfig.testTimeout) {
    (0, _state.getState)().testTimeout = globalConfig.testTimeout;
  }
  (0, _state.getState)().maxConcurrency = globalConfig.maxConcurrency;
  (0, _state.getState)().randomize = globalConfig.randomize;
  (0, _state.getState)().seed = globalConfig.seed;
  console.log('### 2');
  // @ts-expect-error: missing `concurrent` which is added later
  const globalsObject = {
    ..._.default,
    fdescribe: _.default.describe.only,
    fit: _.default.it.only,
    xdescribe: _.default.describe.skip,
    xit: _.default.it.skip,
    xtest: _.default.it.skip
  };
  console.log('### 3', globalsObject);
  (0, _state.addEventHandler)(eventHandler);
  if (environment.handleTestEvent) {
    (0, _state.addEventHandler)(environment.handleTestEvent.bind(environment));
  }
  console.log('expect: ', _expect);
  _expect.jestExpect.setState({
    expand: globalConfig.expand
  });
  const runtimeGlobals = {
    ...globalsObject,
    expect: _expect.jestExpect
  };
  setGlobalsForRuntime(runtimeGlobals);
  if (config.injectGlobals) {
    Object.assign(environment.global, runtimeGlobals);
  }
  console.log('### 4');
  await (0, _state.dispatch)({
    name: 'setup',
    parentProcess,
    runtimeGlobals,
    testNamePattern: globalConfig.testNamePattern
  });

  console.log('### 5');
  if (config.testLocationInResults) {
    await (0, _state.dispatch)({
      name: 'include_test_location_in_result'
    });
  }

  console.log('### 5.1');
  // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.
  // config.snapshotSerializers
  //   .concat()
  //   .reverse()
  //   .forEach(path => (0, _jestSnapshot.addSerializer)(localRequire(path)));
  console.log('### 5.2');
  // const snapshotResolver = await (0, _jestSnapshot.buildSnapshotResolver)(
  //   config,
  //   localRequire
  // );
  console.log('### 5.3');
  // const snapshotPath = snapshotResolver.resolveSnapshotPath(testPath);
  const snapshotState = new SnapshotState('', {});
  console.log('### 5.4');
  _expect.jestExpect.setState({
    snapshotState,
    testPath
  });
  console.log('### 5.5');
  (0, _state.addEventHandler)(handleSnapshotStateAfterRetry(snapshotState));
  if (sendMessageToJest) {
    (0, _state.addEventHandler)(
      (0, _testCaseReportHandler.default)(testPath, sendMessageToJest)
    );
  }

  console.log('### 6');

  // Return it back to the outer scope (test runner outside the VM).
  return {
    globals: globalsObject,
    snapshotState,
  };
};
exports.initialize = initialize;
const runAndTransformResultsToJestFormat = async ({
  config,
  globalConfig,
  testPath
}) => {
  const runResult = await (0, _run.default)();
  let numFailingTests = 0;
  let numPassingTests = 0;
  let numPendingTests = 0;
  let numTodoTests = 0;
  const assertionResults = runResult.testResults.map(testResult => {
    let status;
    if (testResult.status === 'skip') {
      status = 'pending';
      numPendingTests += 1;
    } else if (testResult.status === 'todo') {
      status = 'todo';
      numTodoTests += 1;
    } else if (testResult.errors.length) {
      status = 'failed';
      numFailingTests += 1;
    } else {
      status = 'passed';
      numPassingTests += 1;
    }
    const ancestorTitles = testResult.testPath.filter(
      name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME
    );
    const title = ancestorTitles.pop();
    return {
      ancestorTitles,
      duration: testResult.duration,
      failureDetails: testResult.errorsDetailed,
      failureMessages: testResult.errors,
      fullName: title
        ? ancestorTitles.concat(title).join(' ')
        : ancestorTitles.join(' '),
      invocations: testResult.invocations,
      location: testResult.location,
      numPassingAsserts: testResult.numPassingAsserts,
      retryReasons: testResult.retryReasons,
      status,
      title: testResult.testPath[testResult.testPath.length - 1]
    };
  });
  let failureMessage = (0, _jestMessageUtil.formatResultsErrors)(
    assertionResults,
    config,
    globalConfig,
    testPath
  );
  let testExecError;
  if (runResult.unhandledErrors.length) {
    testExecError = {
      message: '',
      stack: runResult.unhandledErrors.join('\n')
    };
    failureMessage = `${failureMessage || ''}\n\n${runResult.unhandledErrors
      .map(err =>
        (0, _jestMessageUtil.formatExecError)(err, config, globalConfig)
      )
      .join('\n')}`;
  }
  await (0, _state.dispatch)({
    name: 'teardown'
  });
  return {
    ...(0, _testResult.createEmptyTestResult)(),
    console: undefined,
    displayName: config.displayName,
    failureMessage,
    numFailingTests,
    numPassingTests,
    numPendingTests,
    numTodoTests,
    testExecError,
    testFilePath: testPath,
    testResults: assertionResults
  };
};
console.log('## Hittt 3');

exports.runAndTransformResultsToJestFormat = runAndTransformResultsToJestFormat;
const handleSnapshotStateAfterRetry = snapshotState => event => {
  switch (event.name) {
    case 'test_retry': {
      // Clear any snapshot data that occurred in previous test run
      snapshotState.clear();
    }
  }
};

console.log('## Hittt 4' );
const eventHandler = async event => {
  switch (event.name) {
    case 'test_start': {
      _expect.jestExpect.setState({
        currentTestName: (0, _utils.getTestID)(event.test)
      });
      break;
    }
    case 'test_done': {
      event.test.numPassingAsserts =
        _expect.jestExpect.getState().numPassingAsserts;
      _addSuppressedErrors(event.test);
      _addExpectedAssertionErrors(event.test);
      break;
    }
  }
};

console.log('## Hittt 5' );
const _addExpectedAssertionErrors = test => {
  const failures = _expect.jestExpect.extractExpectedAssertionsErrors();
  const errors = failures.map(failure => failure.error);
  test.errors = test.errors.concat(errors);
};

console.log('## Hittt 6' );
// Get suppressed errors from ``jest-matchers`` that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.
const _addSuppressedErrors = test => {
  const {suppressedErrors} = _expect.jestExpect.getState();
  _expect.jestExpect.setState({
    suppressedErrors: []
  });
  if (suppressedErrors.length) {
    test.errors = test.errors.concat(suppressedErrors);
  }
};


